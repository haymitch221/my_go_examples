package calnumbers

// CalInStandardArrZeroToN 计算 m 到 n 这样的连续 int 数组 中有多少个 key 出现，key 在范围 0～9
// 如 m = 0, n = 12, 则[0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ,10, 11, 12] 中 key = 1 出现的次数为 5 次(十进制的表示)
func CalInStandardArrZeroToN(n int, key int) int {
	// TODO ...
	// 循环 m = 0, 0 到 n 复杂度为 On
	// 但能根据十进制位数找到规律，使得复杂度为O(lg(n))
	// 比如 n = 100, key = 2
	//   百位上有2的数有 0 个
	//   十位上有2的数有 10 * 1 个（20 ～ 29），
	//   个位上有2的数有 10 * 1 个（002、012、022 ... 092）
	// 又如 m = 0, n = 311, key = 2
	//   对于小于等于 300 的部分，已确定：
	//   百位上有2的数有 100 个（200～299）
	//   十位上有2的数有 10 * 3个（020 ～ 029，120 ～ 129，220 ～ 229），
	//   个位上有2的数有 10 * 3个（002、012、022 ... 092，102、112、122 ... 192，202、212、222 ... 292）
	//   即 133 个
	//   对于大于 300 的部分：（301 ～ 311）
	//   百位有2的数有 0 个
	//   十位有2的数有 0 个
	//   各位有2的数有 1 个（302）
	// 又如 m = 0, n = x1x2...xl, key = k
	//   how?
	//   也许可以考虑拆分为多个 m 到 n 的个数 相加
	// 又如 m = 0, n = x1x2...xl, key = k
	//   how?
	//   也许可以考虑拆分为多个 m 到 n 的连续 int 数组中的 k 的个数 相加
	//   拆分的依据依靠 十进制的位数，以及 k 这两个指标
	//   到此题目以及以上实例均已引入 m
	// 又如 m = m1m2...ml, n = n1n2...nl（由于 m < n，l 为 n的位数，m没有的位数记为 0 ）, key = k
	//   how?
	return 0
}
